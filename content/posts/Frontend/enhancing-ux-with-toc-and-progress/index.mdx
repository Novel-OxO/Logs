---
title: 블로그 UX 경험 향상시키기 - 목차(ToC)와 진행률 바(Progress Bar) 만들기
description: 긴 기술 블로그 글을 읽는 사용자를 위해 Intersection Observer를 활용한 똑똑한 목차(Table of Contents)와 Framer Motion을 이용한 읽기 진행률 바를 구현하는 과정을 공유합니다.
date: 2026-01-25
category: Frontend
image: "./thumbnail.png"
tags: ["Next.js", "React", "UX", "Framer Motion", "Intersection Observer"]
published: true
---

기술 블로그의 특성상 글이 길어지는 경우가 많습니다. 사용자가 **"지금 내가 어디를 읽고 있는지"**, **"앞으로 얼마나 더 읽어야 하는지"**를 직관적으로 알 수 있게 해주는 것은 매우 중요한 사용자 경험(UX) 요소입니다.

이번 글에서는 제 블로그에 적용한 두 가지 핵심 기능, **Table of Contents(목차)**와 **Scroll Progress Bar(진행률 바)**의 구현 과정을 상세히 다룹니다.

## 1. 읽기 진행률 바 (Scroll Progress Bar)

사용자가 글의 전체 길이 중 어디쯤 와있는지 시각적으로 보여주는 진행률 바는 `framer-motion`을 사용하면 놀라울 정도로 쉽게 구현할 수 있습니다.

### Framer Motion 활용하기

`useScroll` 훅은 스크롤 위치를 감지하고, `useSpring`은 이 값을 부드러운 애니메이션으로 변환해줍니다.

```tsx title="components/scroll-progress.tsx"
"use client";

import { motion, useScroll, useSpring } from "framer-motion";

export function ScrollProgress() {
  const { scrollYProgress } = useScroll();

  // 뚝뚝 끊기지 않고 부드럽게 차오르는 효과를 위해 spring physics 적용
  const scaleX = useSpring(scrollYProgress, {
    stiffness: 100,
    damping: 30,
    restDelta: 0.001,
  });

  return (
    <motion.div
      className="fixed left-0 right-0 top-14 z-50 h-[3px] bg-primary origin-left"
      style={{ scaleX }}
    />
  );
}
```

이 컴포넌트를 `SiteHeader` 컴포넌트 하단에 배치하면, 헤더 바로 아래에 얇은 **Primary Color** 라인이 생겨 스크롤에 따라 부드럽게 늘어납니다.

---

## 2. 똑똑한 목차 (Table of Contents)

목차는 단순한 링크 모음이 아닙니다. **현재 보고 있는 섹션을 실시간으로 알려주는 기능**이 핵심입니다. 이를 위해 `IntersectionObserver` API를 활용했습니다.

### 2-1. Velite 설정으로 헤딩 데이터 추출

먼저 `velite.config.ts`에서 `rehype-slug`와 `rehype-autolink-headings` 플러그인을 사용하여 본문의 헤딩 태그(`h2`, `h3`)에 자동으로 ID를 부여하고, 이를 메타데이터로 추출합니다.

```typescript title="velite.config.ts"
// ...
mdx: {
  rehypePlugins: [
    rehypeSlug, // id="제목" 형태로 자동 생성
    [rehypeAutolinkHeadings, { behavior: "wrap" }], // 앵커 링크 생성
    // ...
  ],
},
// ...
```

### 2-2. Intersection Observer로 활성 섹션 감지

스크롤 위치에 따라 현재 화면에 보이는 섹션을 감시하는 로직입니다.

```tsx title="components/toc.tsx"
useEffect(() => {
  const observer = new IntersectionObserver(
    (entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          setActiveId(entry.target.id);
        }
      });
    },
    // 상단 100px(헤더 공간) 제외, 하단 80% 무시 -> 상단 영역에 집중
    { rootMargin: "-100px 0% -80% 0%" },
  );
  // ...
}, []);
```

여기서 **`rootMargin` 설정이 신의 한 수**입니다.

- `-100px`: 고정 헤더에 가려지는 영역을 고려하여 오프셋을 줍니다.
- `-80%`: 화면 아래쪽 80%에 있는 섹션은 무시합니다. 즉, 사용자가 글을 읽으며 시선이 머무는 **상단 영역**에 진입해야만 활성화됩니다.

### 2-3. "끝까지 내렸을 때" 처리

Intersection Observer의 한계는 **마지막 섹션이 짧아서 화면 상단까지 올라오지 못할 때** 발생합니다. 이를 해결하기 위해 두 가지 장치를 마련했습니다.

1.  **스크롤 이벤트 리스너 추가**: 페이지 바닥에 도달했는지 확인하여 강제로 마지막 항목을 활성화합니다.
2.  **하단 여백 확보**: `pb-[50vh]`를 주어 마지막 섹션도 시원하게 위로 올릴 수 있게 했습니다.

```tsx
// 스크롤이 끝에 도달했는지 체크하는 방어 로직
const handleScroll = () => {
  if (
    window.innerHeight + window.scrollY >=
    document.documentElement.scrollHeight - 100
  ) {
    setActiveId(getLastId(toc)); // 마지막 항목 강제 활성화
  }
};
```

## 3. 고정 헤더와 앵커 링크 문제 해결

ToC 링크를 클릭해서 이동하면, 섹션 제목이 고정 헤더(`sticky header`) 뒤로 숨어버리는 고질적인 문제가 있습니다. 이는 CSS 한 줄로 깔끔하게 해결됩니다.

```css title="app/globals.css"
.prose h1,
.prose h2,
.prose h3 {
  /* 헤더 높이만큼 여유를 두고 스크롤 정지 */
  scroll-margin-top: 100px;
}
```

## 마무리

이제 독자들은 블로그 글을 읽으면서 길을 잃지 않고, 부드러운 인터랙션과 함께 쾌적한 독서 경험을 할 수 있게 되었습니다.
작은 디테일들이 모여 **"계속 읽고 싶은 블로그"**를 만듭니다.
